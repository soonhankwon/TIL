# TIL (Today I Learned)
<details>
<summary>221020 Soul-searching</summary>
<div markdown="1">
<hr/>	
항해 99 부트캠프를 수강한지 벌써 한달이 된 이 시점, 산책같지 않은 산책을 하는 도중 생각나는 것이 있어서 써보려고 한다.
	
나는 청담대교 건너에 있는 대학의 경제학과를 졸업한 무늬만 경제학도이다. 경제학과에서 뭘 배웠느냐 하면❓...

지금 생각나는 건 "공짜 점심은 없다" 라는 기회비용에 관한 것인데, 이는 나라는 사람의 사고 방식을 나도 모르게 지배하고 있는 부분인것 같다.
	
그건 그렇고, 대학교를 다닐 때 내가 빠져있던건 다름 아닌 스노우보드이다. 정말 스노우보드에 미친듯이 빠져있었는데, 
	
겨울에는 11월 부터 3월까지 스키장에 시즌방을 잡아놓고 스노우보드만 주구장창 미친듯이 탔었었다. 친구들이 겨울에는 항상 사라진다고 할 정도로. 평생 보드타고 싶어서 스노우보드 의류 브랜드도 런칭했었었다.🥶
	
대략 20살때부터 33살까지 이러한 패턴으로 탔는데, 하루에 10시간을 넘게 타도 정말 재미있었다.
	
왜 갑자기 뜬금없이 스노우보드타던 생각이 났냐하면, 지금 배우는 프로그래밍과도 과정적으로 비슷한 맥락이 있기 때문이다.

사실, 어느 전공자 분의 벨로그에서 요즘 열풍인 코딩학원에 대한 뼈 때리는 게시글을 봤는데 완벽히 동의하는 부분이다. 

https://velog.io/@mowinckel/%EC%BD%94%EB%94%A9-%ED%95%99%EC%9B%90-%EA%B4%91%EA%B3%A0%EC%99%80-%EB%B9%84%EC%A0%84%EA%B3%B5-%EA%B0%9C%EB%B0%9C%EC%9E%90	

어떤 분야든 대부분 마찬가지지만, 스노우보드 나 스케이트보드🛹 도 기초적인 부분이 약하면 실력이 늘지 않는다. 

최근 몇년은 스케이트보드에 미쳐있었어서 스케이트보드에 비유하면 쫌 괜찮을 것 같다.

스케이트 보드에서 알리가 되지않는데, 트레플립부터 돌리는 상황? 이런 것이 위의 글에서 나타는는 요즘 코딩학원의 현실인듯 싶다.
	
하지만, 여기서 흥미를 느껴야 하는 점이 중요하다고 생각하는데, 입문자들은 이러한 멋있는 것에 대한 상상이 나중에 정말로
	
트레플립을 스타일있게 구사할 수 있는 원동력이 된다고 생각한다. 흥미 자체가 없는 지루한 과정을 하게된다면, 원동력도 사라진다. 

때문에, 처음에 멋도 모르고 예쁜 데크를 사고, 유명 스케이트 비디오를 보면서 기술을 따라하고 그러면서 자기 것이 되는것이다.
	
무엇을 하나 미친듯이 파서 거의 끝을 본 사람의 경험으로써 프로그래밍(코딩)도 이와 마찬가지인 것 같다.
	
학원의 수강 코스를 따라가면서 정말 많은 지식을 주입받는데, 사실 수박 겉핣기라고 생각한다. 스케이트보드로 따지면 **포져**
	
**BUT** 프로그래밍을 처음 접하는 나라는 사람이 무엇을 설계하고 만들수있고, 
	
내가 원하는 분야의 회사에서 서비스를 만들어 공헌하고 싶어진 목표 및 이 분야에 대한 흥미유발을 제대로 했다는 점에 대해서는 RESPECT 하는 부분이다. 
	
조급해지는 나 자신을 보면서, 스노우보드나 스케이트보드를 처음 타던 그 때가 생각났다. 프로그래밍에 관한 여러 유튜브 나 글들을 보고있는 나자신을 보며 
	
스노우보드나 스케이트보드 영상을 보며 열광하고 연구하던 내가 생각난다. 본다고 다 이해되고 바로 할 수 있었던가? 
	
절대 조급해하지 말고 하나를 알아도 제대로 알고 로직적으로 생각하는게 중요하다. 이렇게 써도 정말 어려운 부분이다. 
	
사실 스케이트보드도 알리를 하기 전까지 미친듯이 재미가 없다. 
	
그냥 알리스러운 점프를 하는 것은 하루만해도 할 수 있다. 하지만, 제대로 간지나는 자기 몸같은 알리를 하기위해선 신경써야할 기초, 
	
디테일이 너무 많았었다.(스케이트 보드만큼 발 감각의 사소한 차이에 따라서 결과가 달라지는 것도 없는 것 같다.)
	
그래서 개인적으론 샤빗도 해보고 팝샤빗도해보고 그러면서 돌파했고, 첫 알리를 했을 때 성취감은 경험해본 사람만 안다.

주저리 주저리 두서도 없는 자기성찰이다. 하지만 기초가 탄탄하고 재미까지 느끼는 사람이 항상 미친듯이 실력이 폭발해서 
	
별로 노력하지 않고 짬으로만 타고있던 보더들을 금방 따라오더라...🔥 **화이팅**
	
</div>
</details>

<details>	
<summary>221019 About @RequiredArgsConstructor Annotation</summary>
<div markdown="1">
<hr/>

**Acheivement** : SPRING 심화과정 팀 프로젝트END👏

숙련과정 프로젝트를 다시 한번 복기하는 중이다. 그리고, 백준 기초 알고리즘 문제 7문제 COMPLETED. 시간이 되면 매일 꾸준히 GOGO
  
**Problem** : 현재 단순히 강의를 듣고 따라서 프로그래밍을 하는 부분이 많다(흐름이나 왜 이렇게 쓰는지는 최대한 이해하고 하지만).  

**Feedback** : **내가 만들고 싶은 것이 무엇인지?** 생각하여 내가 만들고 싶은 것을 구현해야겠다. 생각한 아이디어를 구현하고, 배운것을 응용하는 과정에서 부족한 부분을 배워서 발전하는 과정을 가져야겠다🔥
<hr/>

생성자 주입의 단점은 생성자를 만들기 번거롭다는 것이다. 하지만 이를 보완하기 위해 롬복(lombok)을 사용하여 

간단한 방법으로 생성자 주입 방식의 코딩을 할 수 있다. **초기화 되지 않은 final 필드**나, **@NotNull이 붙은 필드**의 생성자를 자동 생성해주는 
롬복 어노테이션이다. DI 편의성을 위해서 사용되곤 한다. 

어떠한 빈(Bean)이 생성자가 오직 하나만 있고, 생성자의 파라미터 타입이 빈으로 등록 가능한 존재라면 이 빈은 @Autowired 어노테이션 없이도 의존성 주입이 가능하다. 

```
@Service
@RequiredArgsConstructor
public class RequiredArgsConstructorDIServiceExample {
	private final First Repository firstRepositorty;
	private final Second Repository secondRepositorty;
	private final Third Repository thirdRepositorty;
}
----> //컴파일 시 아래와 같이 생성됨
@Service
public class RequiredArgsConstructorDIServiceExample {
  @ConstructorProperties({"firstRepository", "secondRepository", "thirdRepository"})
  public RequiredArgsConstructorDIServiceExample(FirstRepository firstRepository, SecondRepository secondRepository, ThirdRepository thirdRepository) {
    this.firstRepository = firstRepository;
    this.secondRepository = secondRepository;
    this.thirdRepository = thirdRepository;
  }
}
```

</div>
</details>
<details>
<summary>221018 About ORM Relationship Mapping Basic</summary>
<div markdown="1">
<hr/>

**Acheivement** : PRING 팀 프로젝트ING🤝 거의 대부분의 기능 구현 완료!

GIT **Merge**과정에서 **Conflict** 해결을 해보았다. 백준 아이디 생성 및 기초 알고리즘 문제 10문제 COMPLETED.
  
**Problem** : Service Business Logic을 짜는데 아직 미숙한 점이 많다. 심화과정들어와서 JPA 영속성 및 데이터베이스, HTTP 등

공부가 꽤나 필요한 이론들을 한꺼번에 많이 접하게되어 두뇌가 어지럽다🤯
    
**Feedback** : 같은 조 팀원분에게 그림으로 로직을 먼저 짜보라는 조언을 받았다. 실제로 많은 도움이 됨👍🏽

**Many to One, One to Many** 에 대한 정확한 이해 필요! -> 엔티티 매핑 관련

하루에 하나정도의 주제로 정확히 숙지해주는 것이 중요하다 생각하고 꼭 실행하자🔥
<hr/>

| 관계 | 코드선언 | Entity | Example | 
| --- | --- | --- |--- |
| 일대다 | @OneToMany | Order(1) : Food(N) | 배달 주문 1개에 음식 여러개 선택 가능
| 다대일 | @ManyToOne | Owner(N) : Restaurant(1) | 음식점 주인 여러명이 하나의 음식점을 소유 가능
| 일대일 | @OneToOne | Order(1) : Coupon(1) | 배달 주문 1개 주문 시, 쿠폰 1개만 할인 적용 가능
| 다대다 | @ManyToMany | User(N) : Restaurant(N) | 고객은 음식점 여러개 찜 가능, 음식점은 고객 여러명에게 찜 가능

<hr/>
  방향 관계를 매핑할 때 둘 중 어떤 것을 사용해야 할지는 <u>반대편 관계</u>에 달려있다. 

반대편이 일대다 관계면 다대일을 사용하고, 반대편이 일대일 관계면 일대일을 사용하면 된다.

다대다 관계는 **지양**하고 다대다 관계에 **연결(조인) Entity**를 생성하여 일대다, 다대일의 명확한 관계를 쓰는것을 **지향**하는 것이 좋다.

WHY❓ : 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없기 때문이다. 따라서 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야 한다. 
</div>
</details>
<details>
<summary>221017 About GIT Branch & Naming (GIT)</summary>
<div markdown="1">
<hr/>

**Acheivement** : SPRING 팀 프로젝트ING🤝

팀원 각자의 GIT Branch에서 작업하고 Merge하는 과정을 실제로 해보았다. 

티스토리에서 하던 TIL을 GIT으로 **MOVE** & 작성해보았다. Notion에서 마크다운 Export하는 방식으로 기본 template 작성.
  
**Problem** : Team project 중 좋아요한 게시글 불러오는 기능을 구현하는데, 데이터베이스 간 일대다, 다대일, 다대다 관계가 꽤나 헷갈림🥲.
    
**Feedback** : One to One, Many to One, One to Many에 대한 심화 이해 필요 및 Service의 비즈니스 로직구현에 대한 연습필요🔥
<hr/>
  
- **Branch의 종류**
    - Main branch
    중앙 저장소에는 수명이 무한한 두 가지 메인브랜치가 있다.
    **Master, Develop** 브랜치이다.
    - Master branch
    제품으로 출시될 수 있는 브랜치
    
    사용자에게 배포 가능한 상태만을 관리한다. 여기서는 배포(release) 이력을 관리하기 위해 사용한다. 즉, 함부로 master브랜치에 Merge하게 되면 상사에게 끌려갈 수 도 있다. **항상 master 브랜치는 주의**하라!
    
    - Develop branch
    다음 출시 버전을 개발하는 브랜치
    
    기능 개발을 위한 브랜치들을 병합하기 위해 사용한다. 즉, 모든 기능이 추가되고 버그가 수정되어 배포가능한 안정적인 상태라면 develop 브랜치를 master브랜치에 merge한다. 평소에는 이 브랜치를 기반으로 개발을 진행한다.
    
    - Release branch
    이번 출시 버전을 준비하는 브랜치
    
    배포를 위한 전용브랜치를 사용함으로써 한팀이 해당 배포를 준비하는 동안 다른 팀은 다음 배포를 위한 기능 개발을 계속할 수 있다. 
    release 브랜치는 배포를 위한 최종적인 버그 수정, 문서 추가 등 배포와 직접적으로 관련된 작업을 수행한다. 이러한 작업들 이외에 새로운 기능을 추가로 merge하지 않는다. 
    
    - hotfix brance
    출시 버전에서 발생한 버그를 수정하는 브랜치
    
    배포한 버전에 긴급하게 수정을 해야 할 필요가 있을 경우, master 브랜치에서 분기하는 브랜치이다. develop 브랜치에서 문제가 되는 부분을 수정하여 배포 가능한 버전을 만들기에는 시간도 많이 소요되고 안정성을 보장하기도 어려우므로 바로 배포가 가능한 master 브랜치에서 직접 브랜치를 만들어 필요한 부분만 수정한 후 다시 master 브랜치에 병합하여 이를 배포하는 것이다.
    
    **Branch 네이밍 규칙**
    
    어떤 방식으로 브랜치의 이름을 정하는지 브랜치 종류에 따라 살펴보자.
    
    **1) master branch, develop branch**
    
    master와 develop 브랜치는 본래 이름 그대로 사용하는 경우가 일반적이다.
    
    **2) feature branch**
    
    - 어떤 이름도 가능하다. 단, `master`, `develop`, `release-...`, `hotfix-...` 같은 이름은 사용할 수 없다.
    - `feature/기능요약` 형식을 추천한다. ex) feature/login
    - `feature/{issue-number}-{feature-name}` 이슈추적을 사용한다면 이와 같은 형식을 따른다.ex) feature/1-init-project, feature/2-build-gradle-script-write
    
    **3) release branch**
    
    - `release-RB_...` 또는 `release-...` 또는 `release/...`같은 이름이 일반적이다.
    - `release-...` 형식을 추천한다. ex) release-1.2
    
    **4) hotfix branch**
    
    - `hotfix-...` 형식을 추천한다. ex) hotfix-1.2.1
    
    - `hotfix-...` 형식을 추천한다. ex) hotfix-1.2.1
    
    📄 Reference 
    
    https://velog.io/@kw2577/Git-branch-%EC%A0%84%EB%9E%B5
   
    </div>
</details>
